import "fun"
import "helper"
import "plugins.my-luasnip.helper" as lsh

chain = helper.chain

s = lsh.s
sn = lsh.sn
t = lsh.t
i = lsh.i
c = lsh.c
d = lsh.d
n = lsh.n
l = lsh.l
dl = lsh.dl
fmt = lsh.fmt
fmta = lsh.fmta
conds = lsh.conds

firstLine = lsh.firstLine
firstInFile = lsh.firstInFile

getNamespaceFromPath = ->
  path = vim.fn.expand("%:h")

  return nil if path == "."

  return fun.iter(vim.fn.split(path, "/"))
    ::map((dir) -> dir:gsub("^%l", string.upper))
    ::foldl((acc, v) -> if acc == nil then v else "#{acc}\\#{v}", nil)

getNamespaceFromFile = ->
  path = vim.fn.expand("%:h")
  filename = vim.fn.expand("%:t")

  file_to_read = fun.iter(vim.fn.readdir(path))
    ::filter((file) -> helper.endsWith(file, ".php") and file ~= filename)
    ::nth(1)

  return nil if file_to_read == nil

  for line in *vim.fn.readfile("#{path}/#{file_to_read}", "", 5)
    return line:match("%w+ (.+);") if helper.startsWith(line, "namespace")
  return nil

getNamespaceLine = (namespace) ->
  sn(nil, {t({"", "namespace "}), i(1, namespace), t({";", ""})})

getNamespace = ->
  result = getNamespaceFromFile()
  result = getNamespaceFromPath() if result == nil

  return if result == nil then "" else getNamespaceFromFile(result)

getClassName = -> sn(nil, i(1, vim.fn.expand("%:t:r")))

export default {
  s(
    "init",
    fmta("<<?php\n<>\nclass <><>\n{\n\t<>\n}", {
      d(1, getNamespace, {}),
      d(2, getClassName, {}),
      i(3),
      i(0),
    }),
    {condition: firstInFile, show_condition: firstLine}
  ),
  -- common
  s("th", t("$this->")),
  s("ei", fmta("elseif (<>) {\n\t<>\n}", {i(1, "true"), i(0)})),
  -- Functions
  s("ufn", t("public function ")),
  s("ofn", t("protected function ")),
  s("ifn", t("private function ")),
  s(
    "fn",
    fmta("<> function <>(<>)\n{\n\t<>\n}", {
      c(1, {
        t("public"),
        t("protected"),
        t("private"),
      }),
      i(2, "functionname"),
      i(3),
      i(0),
    }),
    {
      condition: conds.line_begin,
    }
  ),
  s(
    "fn",
    fmta("function (<>) <><><>{\n\t<>\n}", {
      i(1),
      n(2, "use ("),
      i(2),
      n(2, ") "),
      i(0),
    }),
    {
      condition: chain(conds.line_begin, fun.op.lnot),
    }
  ),
  s("fnn", fmta("fn (<>) =>> <>", { i(1), i(0) })),
  -- For
  s(
    "fo",
    fmta("for (<> = <>; <> <>; <><>) {\n\t<>\n}", {
      i(1, "$i"),
      i(2, "0"),
      dl(3, l._1, 1),
      c(4, {
        sn(nil, {t("< "), i(1, "10")}),
        sn(nil, {t("> "), i(1, "0")}),
        i(nil),
        sn(nil, {t("<= "), i(1, "10")}),
        sn(nil, {t(">= "), i(1, "0")}),
      }),
      dl(5, l._1, 1),
      i(6, "++"),
      i(0),
    })
  ),
  s(
    "fe",
    fmta("foreach (<> as <>) {\n\t<>\n}", {
      i(1),
      c(2, {
        i(nil),
        sn(nil, fmt("{} => {}", { i(1), i(2) })),
      }),
      i(0),
    })
  ),
}
